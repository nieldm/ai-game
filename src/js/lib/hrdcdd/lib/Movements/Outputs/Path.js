// Generated by CoffeeScript 1.7.1
(function() {
  define(['Phaser'], function(Phaser) {
    var Path;
    Path = (function() {
      function Path(game, drawer) {
        this.game = game;
        this.drawer = drawer;
        this.points = [];
        this.handles = [];
      }

      Path.prototype.make = function(start, end, precision) {
        var x, _i;
        for (x = _i = start; precision > 0 ? _i <= end : _i >= end; x = _i += precision) {
          if (x >= 0 && x < 200) {
            this.points.push(new Phaser.Point(x, x + 2));
          }
          if (x >= 200 && x < 300) {
            this.points.push(new Phaser.Point(x, x / 3));
          }
          if (x >= 300) {
            this.points.push(new Phaser.Point(x, x - 1));
          }
        }
        return this.points;
      };

      Path.prototype.create = function() {
        var handle, key, line, next, point, _i, _len, _ref, _results;
        _ref = this.points;
        _results = [];
        for (key = _i = 0, _len = _ref.length; _i < _len; key = ++_i) {
          point = _ref[key];
          handle = this.game.add.sprite(point.x, point.y, 'star');
          handle.inputEnabled = true;
          handle.input.enableDrag(true);
          if (this.points[key + 1] != null) {
            next = this.points[key + 1];
            line = new Phaser.Line(point.x, point.y, next.x, next.y);
          }
          _results.push(this.handles.push([handle != null ? handle : void 0, next != null ? next : void 0, line != null ? line : void 0]));
        }
        return _results;
      };

      Path.prototype.update = function() {
        var handle, key, lineColor, _i, _len, _ref, _results;
        this.drawer.clear();
        _ref = this.handles;
        _results = [];
        for (key = _i = 0, _len = _ref.length; _i < _len; key = ++_i) {
          handle = _ref[key];
          if ((handle[0] != null) && (this.handles[key + 1] != null)) {
            handle[2].fromSprite(handle[0], this.handles[key + 1][0], true);
            lineColor = 0xFF0000;
            this.drawer.beginFill(lineColor);
            this.drawer.lineStyle(1, lineColor, 1);
            this.drawer.moveTo(handle[2].start.x, handle[2].start.y);
            this.drawer.lineTo(handle[2].end.x, handle[2].end.y);
            _results.push(this.drawer.endFill());
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      Path.prototype.getParam = function(futurePos, currrentPos) {
        var down, handle, iPoint, interDown, interLeft, interRight, interUp, intersectPoints, key, left, lineAplha, lineColor, lineWidth, nearestPoint, right, up, _i, _j, _len, _len1, _ref;
        intersectPoints = [];
        lineColor = 0xFF00F0;
        this.drawer.beginFill(lineColor);
        this.drawer.lineStyle(1, lineColor, 1);
        this.drawer.drawCircle(futurePos.x, futurePos.y, 4);
        this.drawer.endFill();
        lineAplha = 0.5;
        lineWidth = 0.5;
        lineColor = 0x00FF00;
        this.drawer.beginFill(lineColor);
        this.drawer.lineStyle(lineWidth, lineColor, lineAplha);
        up = new Phaser.Line(futurePos.x, futurePos.y, futurePos.x, 0);
        this.drawer.moveTo(up.start.x, up.start.y);
        this.drawer.lineTo(up.end.x, up.end.y);
        this.drawer.endFill();
        this.drawer.beginFill(lineColor);
        this.drawer.lineStyle(lineWidth, lineColor, lineAplha);
        right = new Phaser.Line(futurePos.x, futurePos.y, this.game.world.width, futurePos.y);
        this.drawer.moveTo(right.start.x, right.start.y);
        this.drawer.lineTo(right.end.x, right.end.y);
        this.drawer.endFill();
        this.drawer.beginFill(lineColor);
        this.drawer.lineStyle(lineWidth, lineColor, lineAplha);
        down = new Phaser.Line(futurePos.x, futurePos.y, futurePos.x, this.game.world.height);
        this.drawer.moveTo(down.start.x, down.start.y);
        this.drawer.lineTo(down.end.x, down.end.y);
        this.drawer.endFill();
        this.drawer.beginFill(lineColor);
        this.drawer.lineStyle(lineWidth, lineColor, lineAplha);
        left = new Phaser.Line(futurePos.x, futurePos.y, 0, futurePos.y);
        this.drawer.moveTo(left.start.x, left.start.y);
        this.drawer.lineTo(left.end.x, left.end.y);
        this.drawer.endFill();
        lineColor = 0xF00F00;
        this.drawer.beginFill(lineColor);
        this.drawer.lineStyle(1, lineColor, 1);
        _ref = this.handles;
        for (key = _i = 0, _len = _ref.length; _i < _len; key = ++_i) {
          handle = _ref[key];
          if (handle[2] != null) {
            interUp = up.intersects(handle[2], true);
            if (interUp != null) {
              this.drawer.drawCircle(interUp.x, interUp.y, 4);
              intersectPoints.push([up.start, interUp, Phaser.Point.distance(up.start, interUp)]);
            }
            interRight = right.intersects(handle[2], true);
            if (interRight != null) {
              this.drawer.drawCircle(interRight.x, interRight.y, 4);
              intersectPoints.push([right.start, interRight, Phaser.Point.distance(right.start, interRight)]);
            }
            interDown = down.intersects(handle[2], true);
            if (interDown != null) {
              this.drawer.drawCircle(interDown.x, interDown.y, 4);
              intersectPoints.push([down.start, interDown, Phaser.Point.distance(down.start, interDown)]);
            }
            interLeft = left.intersects(handle[2], true);
            if (interLeft != null) {
              this.drawer.drawCircle(interLeft.x, interLeft.y, 4);
              intersectPoints.push([left.start, interLeft, Phaser.Point.distance(left.start, interLeft)]);
            }
          }
        }
        this.drawer.endFill();
        nearestPoint = [];
        nearestPoint.distance = null;
        nearestPoint.point = null;
        for (_j = 0, _len1 = intersectPoints.length; _j < _len1; _j++) {
          iPoint = intersectPoints[_j];
          if (iPoint[2] < nearestPoint.distance || (nearestPoint.distance == null)) {
            nearestPoint.distance = iPoint[2];
            nearestPoint.point = iPoint[1];
          }
        }
        if (nearestPoint.point != null) {
          lineColor = 0xFFFF00;
          this.drawer.beginFill(lineColor);
          this.drawer.lineStyle(1, lineColor, 1);
          this.drawer.drawCircle(nearestPoint.point.x, nearestPoint.point.y, 6);
          this.drawer.endFill();
        }
        return nearestPoint.point;
      };

      return Path;

    })();
    return Path;
  });

}).call(this);
